<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>LINKS</title>
  <script src="libs/d3.v4.min.js"></script>
  <style type="text/css">
    text{
        font-family: "Courier"
    }
    html, body, #graph {
        width: 900px;
        height: 500px;
    }
    .node {
      stroke: #000;
      stroke-width: 1.5px;
    }

    .link {
      stroke: #999;
      stroke-width: 1.5px;
    }
  </style>
</head>
<body>
  <div id="graph"></div>    
  <script type="text/javascript">
    
    //preparing our data in a nice format for a nodes and links visualisation
    var allWords = [];
    var listWords = [];

    var totalKeywords = [];
    var focusKeywords = [];
    var filterNum = .8;
    var uniqueMostKeyed;

    var links = [];
    var nodes = [];


    var width, height; 
    var chartWidth, chartHeight; 
    var margin; 
    var svg = d3.select("#graph").append("svg");
    var chartLayer = svg.append("g").classed("chartLayer", true);
        width = document.querySelector("#graph").clientWidth
        height = document.querySelector("#graph").clientHeight
    
        margin = {top:10, left:10, bottom:10, right:10 }
        
        chartWidth = width - (margin.left+margin.right)
        chartHeight = height - (margin.top+margin.bottom)
        
        svg.attr("width", width).attr("height", height)

        chartLayer
            .attr("width", chartWidth)
            .attr("height", chartHeight)
            .attr("transform", "translate("+[margin.left, margin.top]+")")

        var words = ["this is one","this is one this is another","this is one this is another this is more","this is one","this is one and another and another and another","this is one and another and another and another this is one and another and another and another"]; 
        main();
    function main() {
        for (var i = 0; i<words.length; i++){
          listWords[i]=words[i].split(" ");           

          //then let's put all the words used in a long array
          for (j=0; j<listWords[i].length; j++){
            allWords.push(listWords[i][j]);   
          }
          //then let's find the most used words from this long array
        }
        next();
      }
    var uniqueKeywords;
    function next(){
      //here we will find out which words are unique from the long list
      uniqueKeywords = allWords.filter( onlyUnique ); 
      next2();
    }
    function onlyUnique(value, index, self) { 
        return self.indexOf(value) === index;
    } 
    function keyConsolidation(givenKey,i) { 
        var total = 0;
        for (i = 0; i<allWords.length; i++){ 
            if(allWords[i] == givenKey){
                total++;
            }else{
            }
        }
        return total;
     } 

      function next2(){
        for (i = 0; i<allWords.length; i++){
          totalKeywords[i] = keyConsolidation(allWords[i]); //this counts the number of times the words are used 
          var mostKeyed = d3.max(totalKeywords); //what is the highest number of times a word has been used?    
          if(totalKeywords[i]>mostKeyed*filterNum){ //so if a word has been used a LOT - but still relative to the amount other words have been used, put it in the "focused keywords" array
            focusKeywords.push(allWords[i]);
          }
        }
        uniqueMostKeyed = focusKeywords.filter( onlyUnique ); //then let's just keep the words that have been used a lot - only one representative word for each
        next3();
      }
      function next3(){
        for (i=0; i<words.length; i++){ 
            for (j=0; j<uniqueMostKeyed.length; j++){ 
                if (listWords[i].indexOf(uniqueMostKeyed[j])!=-1){
                  links.push({"source":listWords[i],"target":uniqueMostKeyed[j]});
                  nodes.push({"id":uniqueMostKeyed[j]}) 
                }
            }
        }    
        simpleNodes();        
      }

      function simpleNodes(){

        var simulation = d3.forceSimulation()
          .force("charge", d3.forceManyBody().strength(-200))
          .force("link", d3.forceLink().id(function(d) { return d.id; }).distance(40))
          .force("x", d3.forceX(width / 2))
          .force("y", d3.forceY(height / 2))
          .on("tick", ticked);

        var link = chartLayer.selectAll(".link"),
            node = chartLayer.selectAll(".node"); 

            simulation.nodes(nodes);
            simulation.force("link").links(links);

            link = link
              .data(links)
              .enter().append("line")
                .attr("class", "link");

            node = node
              .data(nodes)
              .enter().append("circle")
                .attr("class", "node")
                .attr("r", 6)
                // .style("fill", function(d) { return d.id; })
                .attr("class", function(d){
                  return d.id;
                })
     
          function ticked() {
            link.attr("x1", function(d) { return d.source.x; })
                .attr("y1", function(d) { return d.source.y; })
                .attr("x2", function(d) { return d.target.x; })
                .attr("y2", function(d) { return d.target.y; });

            node.attr("cx", function(d) { return d.x; })
                .attr("cy", function(d) { return d.y; });
          }
      }


//more complex data set
    // var words = [];
    // d3.csv("brexitTweets.csv", function(data){
    //   words = data.columns;
    //   main();
    // })


</script>
</body>
</html>